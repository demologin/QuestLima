{
  "4001": {
    "id": 4001,
    "question": "Что такое Big O? Как происходит оценка асимптотической сложности алгоритмов?",
    "answer": "Big O (O большое / символ Ландау)  - математическое обозначение порядка функции для сравнения асимптотического поведения функций. <p>Асимптотика - характер изменения функции при стремлении ее аргумента к определённой точке. <p>Любой алгоритм состоит из неделимых операций процессора(шагов), поэтому нужно измерять время в операциях процессора, вместо секунд. <p>DTIME - количество шагов(операций процессора), необходимых, чтобы алгоритм завершился. Временная сложность обычно оценивается путём подсчёта числа элементарных операций, осуществляемых алгоритмом. Время исполнения одной такой операции при этом берётся константой, то есть асимптотически оценивается как O(1).  Сложность алгоритма состоит из двух факторов: временная сложность и сложность по памяти. <p>Временная сложность - функция, представляющая зависимость количество операций процессора, необходимых, чтобы алгоритм завершился, от размера входных данных. Все неделимые операции языка(операции сравнения, арифметические, логические, инициализации и возврата) считаются выполняемыми за 1 операцию процессора, эта погрешность считается приемлемой. При росте N, слагаемые с меньшей скорость роста всё меньше влияют на значение функции. Поэтому, вне зависимости от констант при слагаемых, слагаемое с большей скорость роста определяет значение функции. Данное слагаемое называют порядком функции. Пример: Т(N) = 5 * N^2 + 999 * N... Где (5 * N^2) и (9999 * N) являются слагаемыми функции. Константы(5 и 999) не указываются в рамках нотации Big O, так как не показывают абсолютную сложность алгоритма, так как могут изменяться в зависимости от машины, поэтому сложность равна О(N^2) <p>В порядке возрастания сложности: <p>1. O(1) - константная, чтение по индексу из массива <p>2. O(log(n)) - логарифмическая, бинарный поиск в отсортированном массиве <p>3. O(√n) - сублинейная <p>4. O(n) - линейная, перебор массива в цикле, два цикла подряд, линейный поиск наименьшего или наибольшего элемента в неотсортированном массиве <p>5. O(n*log(n)) - квазилинейная, сортировка слиянием, сортировка кучей <p>6. O(n^2) - полиномиальная(квадратичная), вложенный цикл, перебор двумерного массива, сортировка пузырьком, сортировка вставками <p>7. O(2^n) - экспоненциальная, алгоритмы разложения на множители целых чисел <p>8. O(n!) - факториальная, решение задачи коммивояжёра полным перебором <p>Алгоритм считается приемлемым, если сложность не превышает O(n*log(n)), иначе говнокод.",
    "images": "images/dbImage/4001.png"
  },
  "4002": {
    "id": 4002,
    "question": "Что такое рекурсия? Сравните преимущества и недостатки итеративных и рекурсивных алгоритмов. С примерами.",
    "answer": "Рекурсия - способ отображения какого-либо процесса внутри самого этого процесса, то есть ситуация, когда процесс является частью самого себя. <p>Рекурсия состоит из базового случая и шага рекурсии. Базовый случай представляет собой самую простую задачу, которая решается за одну итерацию, например, if(n == 0) return 1. <p>В базовом случае обязательно  присутствует условие выхода из рекурсии; <p>Смысл рекурсии в движении от исходной задачи к базовому случаю, пошагово уменьшая размер исходной задачи на каждом шаге рекурсии. <p>После того, как будет найден базовый случай, срабатывает условие выхода из рекурсии, и стек рекурсивных вызовов разворачивается в обратном порядке, пересчитывая результат исходной задачи, который основан на результате, найденном в базовом случае. <p>Рекурсия имеет линейную сложность O(n); <p>Циклы дают лучшую производительность, чем рекурсивные вызовы, поскольку вызовы методов потребляют больше ресурсов, чем исполнение обычных операторов. <p>Циклы гарантируют отсутствие переполнения стека, т.к. не требуется выделения доп. памяти. <p>В случае рекурсии стек вызовов разрастается, и его необходимо просматривать для получения конечного ответа. <p>При использовании головной рекурсии также необходимо принимать во внимание размер стека. <p>Если уровней вложненности много или изменятся, то предпочительна рекурсия. Если их несколько, то лучше цикл."
  },
  "4003": {
    "id": 4003,
    "question": "Что такое жадные алгоритмы? Приведите пример.",
    "answer": "Жадные алгоритмы являются одной из 3х техник создания алгоритмов, вместе с принципом &#8222Разделяй и властвуй&#8221, и динамическим программированием. <p>Жадный алгоритм - это алгоритм, который на каждом шагу совершает локально оптимальные решения, т.е. максимально возможное из допустимых, не учитывая предыдущие или следующие шаги. Последовательность этих локально оптимальных решений приводит (не всегда) к глобально оптимальному решению. Т.е. задача рабивается на подзадачи, в каждой подзадаче делается оптимальное решение и, в итоге, вся задача решается оптимально. При этом важно является ли каждое локальное решение безопасным шагом. Безопасный шаг - приводящий к оптимальному решению. <p>К примеру, алгоритм Дейкстры нахождения кратчайшего пути в графе вполне себе жадный, потому что мы на каждом шагу ищем вершину с наименьшим весом, в которой мы еще не бывали, после чего обновляем значения других вершин. При этом можно доказать, что кратчайшие пути, найденные в вершинах, являются оптимальными."
  },
  "4004": {
    "id": 4004,
    "question": "Расскажите про пузырьковую сортировку.",
    "answer": "Будем идти по массиву слева направо. Если текущий элемент больше следующего, меняем их местами. Делаем так, пока массив не будет отсортирован. <p>Aсимптотика в худшем и среднем случае – O(n^2), в лучшем случае – O(n) - массив уже отсортирован. "
  },
  "4005": {
    "id": 4005,
    "question": "Расскажите про быструю сортировку.",
    "answer": "Выберем некоторый опорный элемент(pivot). После этого перекинем все элементы, меньшие его, налево, а большие – направо. Для этого используются дополнительные переменные - значения слева и справа, которые сравниваются с pivot. Рекурсивно вызовемся от каждой из частей, где будет выбран новый pivot. В итоге получим отсортированный массив, так как каждый элемент меньше опорного стоял раньше каждого большего опорного. <p>Асимптотика: O(n*log(n)) в среднем и лучшем случае. Наихудшая оценка O(n^2) достигается при неудачном выборе опорного элемента."
  },
  "4006": {
    "id": 4006,
    "question": "Расскажите про сортировку слиянием.",
    "answer": "Основана на парадигме «разделяй и властвуй». Будем делись массив пополам, пока не получим множество массивов из одного элемента. После чего выполним процедуру слияния: поддерживаем два указателя, один на текущий элемент первой части, второй – на текущий элемент второй части. Из этих двух элементов выбираем минимальный, вставляем в ответ и сдвигаем указатель, соответствующий минимуму. Так сделаем слияния массивов из 1го элемента в массивы по 2 элемента, затем из 2х в 4 и т.д. Слияние работает за O(n), уровней всего log(n), поэтому асимптотика O(n*log(n))."
  },
  "4007": {
    "id": 4007,
    "question": "Расскажите про бинарное дерево.",
    "answer": "Бинарное дерево - иерархическая структура данных, в которой каждый узел может иметь двух потомков. Как правило, первый называется родительским узлом, а наследники называются левым и правым нодами/узлами. Каждый узел в дереве задаёт поддерево, корнем которого он является. Оба поддерева — левое и правое — тоже являются бинарными деревьями. Ноды, которые не имеют потомков, называются листьями дерева. У всех узлов левого поддерева произвольного узла X значения ключей данных меньше, нежели значение ключа данных самого узла X. У всех узлов правого поддерева произвольного узла X значения ключей данных больше либо равны, нежели значение ключа данных самого узла X. Этим достигается упорядоченная структура данных, то есть всегда отсортированная. <p>Поиск в лучшем случае - O(log(n)), худшем - O(n) -  при вырождении в связанный список."
  },
  "4008": {
    "id": 4008,
    "question": "Расскажите про красно-черное дерево.",
    "answer": "Усовершенствованная версия бинарного дерева. Каждый узел в к/ч дереве имеет дополнительное поле - цвет. К/ч дерево отвечает следующим требованиям: <p>1) Узел либо красный, либо черный. <p>2) Корень - черный. <p>3) Все листья - черные и не хранят данных. <p>4) Оба потомка каждого красного узла - черные. <p>5) Любой простой путь от узла-предка до листового узла-потомка содержит одинаковое число черных узлов.(это называется черная высота) Если не одинаковое, то происходит переворот. <p>При добавлении постоянно увеличивающихся/уменьшающихся чисел в бинарное дерево, оно вырождается в связанный список и теряет свои преимущества. Тогда как к/ч дерево может потребовать до двух поворотов для поддержки сбалансированности, чтобы избежать вырождения. <p>При операциях удаления в бинарном дереве для удаляемого узла надо найти замену. К/ч дерево сделает тоже самое, но потребует до трёх поворотов для поддержки сбалансированности. <p>В этом и состоит преимущство. <p>Сложность поиска, вставки и удаления - O(log(n))"
  },
  "4009": {
    "id": 4009,
    "question": "Расскажите про линейный и бинарный поиск.",
    "answer": "Линейный поиск - сложность O(n), так как все элементы проверяются по очереди. <p>Бинарный поиск - O(log(n)). Массив должен быть отсортирован. Происходит поиск индекса в массиве, содержащего искомое значение. <p>1) Берем значение из середины массива и сраваем с искомым. Индекс середины считается по формуле mid = (high + low) / 2 <p>low - индекс начала левого подмассива, high - индекс конца правого подмассива. <p>2) Если значение в середине больше искомого, то рассматриваем левый подмассив и high = middle - 1 <p>3) Если меньше, то правый и low = middle + 1 <p>4) Повторяем, пока mid не страновится равен искомому элементу или подмассив не станет пустым.",
    "images": "images/dbImage/4009.png"
  },
  "4010": {
    "id": 4010,
    "question": "Расскажите про очередь и стек.",
    "answer": "Stack это область хранения данных, находящееся в общей оперативной памяти (RAM). Всякий раз, когда вызывается метод, в памяти стека создается новый блок-фрейм, который содержит локальные переменные метода и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче. Стек в Java работает по схеме LIFO <p>Queue - это очередь, которая обычно (но необязательно) строится по принципу FIFO (First-In-First-Out) - соответственно извлечение элемента осуществляется с начала очереди, вставка элемента - в конец очереди. Хотя этот принцип нарушает, к примеру PriorityQueue, использующая «natural ordering» или переданный Comparator при вставке нового элемента. <p>Deque (Double Ended Queue) расширяет Queue и согласно документации это линейная коллекция, поддерживающая вставку/извлечение элементов с обоих концов. Помимо этого реализации интерфейса Deque могут строится по принципу FIFO, либо LIFO. Реализации и Deque, и Queue обычно не переопределяют методы equals() и hashCode(), вместо этого используются унаследованные методы класса Object, основанные на сравнении ссылок."
  },
  "4011": {
    "id": 4011,
    "question": "Сравните сложность вставки, удаления, поиска и доступа по индексу в ArrayList и LinkedList.",
    "answer": "",
    "images": "images/dbImage/4011.png"
  }
}