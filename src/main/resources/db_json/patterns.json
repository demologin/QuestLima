{
  "5001": {
    "id": 5001,
    "question": "Что такое «шаблон проектирования»?",
    "answer": "Проверенное и готовое к использованию логическое решение, которе может быть реализовано по-разному в разных языках программирования. <p>Плюсы: <p>-снижение сложности разработки за счёт готовых абстракций облегчение <p>-коммуникации между разработчиками <p>Минусы: <p>-слепое следование некоторому шаблону может привести к усложнению программы. <p>-желание попробовать некоторый шаблон в деле без особых на то оснований."
  },
  "5002": {
    "id": 5002,
    "question": "Назовите основные характеристики шаблонов.",
    "answer": "Имя - все шаблоны имеют уникальное имя, служащее для их идентификации; <p>Назначение данного шаблона; <p>Задача, которую шаблон позволяет решить; <p>Способ решения, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден; <p>Участники - сущности, принимающие участие в решении задачи; <p>Следствия от использования шаблона как результат действий, выполняемых в шаблоне; <p>Реализация - возможный вариант реализации шаблона."
  },
  "5003": {
    "id": 5003,
    "question": "Назовите три основные группы паттернов.",
    "answer": "Порождающие - отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов без внесения в программу лишних зависимостей. <p>Структурные - отвечают за построение удобных в поддержке иерархий классов <p>Поведенческие - заботятся об эффективной коммуникации между объектами. <p>Основные - основные строительные блоки, используемые для построения других шаблонов. Например, интерфейс."
  },
  "5004": {
    "id": 5004,
    "question": "Расскажите про паттерн Одиночка (Singleton)",
    "answer": "Порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа. Конструктор помечается как private, а для создания нового объекта Singleton использует специальный метод getInstance(). Он либо создаёт объект, либо отдаёт существующий объект, если он уже был создан. <p>+ : можно не создавать множество объектов для ресурсоемких задач, а пользоваться одним <p>- : нарушает принцип единой ответственности, так как его могут использовать множество объектов <p>Почему считается антипаттерном? <p>-Нельзя тестировать с помощью mock, но можно использовать powerMock. <p>-Нарушает принцип единой ответственности <p>-Нарушает Open/Close принцип, его нельзя расширить <p>Можно ли его синхронизировать без synchronized у метода? <p>-Можно сделать его Enum (eager). Это статический final класс с константами. JVM загружает final и static классы на этапе компиляции, а значит несколько потоков не могут создать несколько инстансов. <p>-C помощью double checked locking (lazy).<p>",
    "images": ["images/dbImage/5004.1.png", "images/dbImage/5004.2.png"]
  },
  "5005": {
    "id": 5005,
    "question": "Расскажите про паттерн Строитель (Builder).",
    "answer": "Порождающий паттерн, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений одного объекта. Паттерн предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, называемым строителями. Процесс конструирования объекта разбить на отдельные шаги (например, построитьСтены, вставитьДвери). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации. Можно пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый директором. В этом случае директор будет задавать порядок шагов строительства, а строитель — выполнять их. <p>+ : Позволяет использовать один и тот же код для создания различных объектов. Изолирует сложный код сборки объектов от его основной бизнес-логики. <p>- : Усложняет код программы из-за введения дополнительных классов."
  },
  "5006": {
    "id": 5006,
    "question": "Расскажите про паттерн Строитель (Builder).",
    "answer": "Порождающий паттерн, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений одного объекта. <p>Паттерн предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, называемым строителями. Процесс конструирования объекта разбить на отдельные шаги (например, построитьСтены, вставитьДвери). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации. Можно пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый директором. В этом случае директор будет задавать порядок шагов строительства, а строитель — выполнять их. <p>+ : Позволяет использовать один и тот же код для создания различных объектов. Изолирует сложный код сборки объектов от его основной бизнес-логики. <p>- : Усложняет код программы из-за введения дополнительных классов."
  },
  "5007": {
    "id": 5007,
    "question": "Расскажите про паттерн Фабричный метод (Factory Method).",
    "answer": "Порождающий шаблон проектирования, в котором подклассы имплементируют общий интерфейс с методом для создания объектов. Переопределенный метод в каждом наследнике возвращает нужный вариант объекта. <p>Объекты всё равно будут создаваться при помощи new, но делать это будет фабричный метод. Таким образом можно переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта. Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу. <p>+ : Выделяет код производства объектов в одно место, упрощая поддержку кода. Реализует принцип открытости/закрытости. <p>- : Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя."
  },
  "5008": {
    "id": 5008,
    "question": "Расскажите про паттерн Абстрактная фабрика (Abstract Factory).",
    "answer": "Порождающий паттерн проектирования, который представляет собой интерфейс для создания других классов, не привязываясь к конкретным классам создаваемых объектов. <p>Абстрактная фабрика предлагает выделить общие интерфейсы для отдельных продуктов, составляющих семейства. Так, все вариации кресел получат общий интерфейс Кресло, все диваны реализуют интерфейс Диван и так далее. Далее вы создаёте абстрактную фабрику — общий интерфейс, который содержит фабричные методы создания всех продуктов семейства (например, создатьКресло, создатьДиван и создатьСтолик). Эти операции должны возвращать абстрактные типы продуктов, представленные интерфейсами, которые мы выделили ранее — Кресла, Диваны и Столики. <p>+ : гарантированно будет создаваться тип одного семейства <p>- : Усложняет код программы из-за введения множества дополнительных классов."
  },
  "5009": {
    "id": 5009,
    "question": "Расскажите про паттерн Прототип (Prototype).",
    "answer": "Порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации. <p>Паттерн поручает создание копий самим копируемым объектам. Он вводит общий интерфейс с методом clone для всех объектов, поддерживающих клонирование. Реализация этого метода в разных классах очень схожа. Метод создаёт новый объект текущего класса и копирует в него значения всех полей собственного объекта. <p>+ : Позволяет клонировать объекты, не привязываясь к их конкретным классам. <p>- : Сложно клонировать составные объекты, имеющие ссылки на другие объекты."
  },
  "5010": {
    "id": 5010,
    "question": "Расскажите про паттерн Адаптер (Adapter).",
    "answer": "Структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. <p>Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту. При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого. <p>+ : Отделяет и скрывает от клиента подробности преобразования различных интерфейсов. <p>- : Усложняет код программы из-за введения дополнительных классов."
  },
  "5011": {
    "id": 5011,
    "question": "Расскажите про паттерн Декоратор (Decorator).",
    "answer": "Структурный паттерн проектирования, который позволяет добавлять объектам новую функциональность, оборачивая их в полезные «обёртки». <p>Целевой объект помещается в другой объект-обёртку, который запускает базовое поведение обёрнутого объекта, а затем добавляет к результату что-то своё. Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу. Адаптер не менят состояния объекта, а декоратор может менять. <p>+ : Большая гибкость, чем у наследования. <p>- : Труднее конфигурировать многократно обёрнутые объекты."
  },
  "5012": {
    "id": 5012,
    "question": "Расскажите про паттерн Заместитель (Proxy).",
    "answer": "Структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители, которые перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу. <p>Заместитель предлагает создать новый класс-дублёр, имеющий тот же интерфейс, что и оригинальный служебный объект. При получении запроса от клиента объект-заместитель сам бы создавал экземпляр служебного объекта, выполняя промежуточную логику, которая выполнялась бы до (или после) вызовов этих же методов в настоящем объекте. <p>+ : Позволяет контролировать сервисный объект незаметно для клиента. <p>- : Увеличивает время отклика от сервиса."
  },
  "5013": {
    "id": 5013,
    "question": "Расскажите про паттерн Итератор (Iterator).",
    "answer": "Поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления. <p>Идея состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс. <p>Детали: Создается итератор и интерфейс, который возвращает итератор. В классе, в котором надо будет вызывать итератор, имплементируем интерфейс, возвращающий итератор, а сам итератор делаем там нестатическим вложенным классом, так как он нигде использоваться больше не будет."
  },
  "5014": {
    "id": 5014,
    "question": "Расскажите про паттерн Шаблонный метод (Template Method).",
    "answer": "Поведенческий паттерн проектирования, который пошагово определяет алгоритм и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом. <p>Паттерн предлагает разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и вызывать их в одном шаблонном методе друг за другом. Для описания шагов используется абстрактный класс. Общие шаги можно будет описать прямо в абстрактном класе. Это позволит подклассам переопределять некоторые шаги алгоритма, оставляя без изменений его структуру и остальные шаги, которые для этого подкласса не так важны."
  },
  "5015": {
    "id": 5015,
    "question": "Расскажите про паттерн Цепочка обязанностей (Chain of Responsibility).",
    "answer": "Поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи. <p>Базируется на том, чтобы превратить каждую проверку в отдельный класс с единственным методом выполнения. Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы. <p>Каждый из методов будет иметь ссылку на следующий метод-обработчик, что образует цепь. Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке. Может и не передавать, если проверка в одном из методов не прошла, например."
  },
  "5016": {
    "id": 5016,
    "question": "Какие паттерны используются в Spring Framework?",
    "answer": "Singleton - Bean scopes, <p>Factory - Bean Factory classes <p>Prototype - Bean scopes <p>Adapter - Spring Web and Spring MVC <p>Proxy - Spring Aspect Oriented Programming support <p>Template Method - JdbcTemplate, HibernateTemplate etc <p>Front Controller - Spring MVC DispatcherServlet <p>DAO - Spring Data Access Object support <p>Dependency Injection"
  },
  "5017": {
    "id": 5017,
    "question": "Какие паттерны используются в Hibernate?",
    "answer": "Domain Model – объектная модель предметной области, включающая в себя как поведение так и данные. <p>Data Mapper – слой мапперов (Mappers), который передает данные между объектами и базой данных, сохраняя их независимыми друг от друга и себя. <p>Proxy  — применяется для ленивой загрузки. <p>Factory — используется в SessionFactory"
  },
  "5018": {
    "id": 5018,
    "question": "Шаблоны GRASP: Low Coupling (низкая связанность) и High Cohesion (высокая сплоченность)",
    "answer": "Low Coupling - части системы, которые изменяются вместе, должны находиться близко друг к другу. <p>High Cohesion - если возвести Low Coupling в абсолют, то можно прийти к тому, чтобы разместить всю функциональность в одном единственном классе. В таком случае связей не будет вообще, но что-то тут явно не так, ведь в этот класс попадет совершенно несвязанная между собой бизнес-логика. Принцип High Cohesion говорит следующее: части системы, которые изменяются параллельно, должны иметь как можно меньше зависимостей друг на друга. <p>Low Coupling и High Cohesion представляют из себя два связанных между собой паттерна, рассматривать которые имеет смысл только вместе. Их суть: система должна состоять из слабо связанных классов, которые содержат связанную бизнес-логику. Соблюдение этих принципов позволяет удобно переиспользовать созданные классы, не теряя понимания о их зоне ответственности."
  },
  "5019": {
    "id": 5019,
    "question": "Расскажите про паттерн Saga",
    "answer": "Сага — это механизм, обеспечивающий согласованность данных в микросервисах без применения распределенных транзакций. <p>Для каждой системной команды, которой надо обновлять данные в нескольких сервисах, создается некоторая сага. Сага представляет из себя некоторый «чек-лист», состоящий из последовательных локальных ACID-транзакций, каждая из которых обновляет данные в одном сервисе. Для обработки сбоев применяется компенсирующая транзакция. Такие транзакции выполняются в случае сбоя на всех сервисах, на которых локальные транзакции выполнились успешно. <p>Типов транзакций в саге четыре: <p>Компенсирующая — отменяет изменение, сделанное локальной транзакцией. <p>Компенсируемая — это транзакция, которую необходимо компенсировать (отменить) в случае, если последующие транзакции завершаются неудачей. <p>Поворотная — транзакция, опеределяющая успешность всей саги. Если она выполняется успешно, то сага гарантированно дойдет до конца. <p>Повторяемая — идет после поворотной и гарантированно завершается успехом."
  }
}