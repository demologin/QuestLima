{
  "2001": {
    "id": 2001,
    "question": "Что такое дженерики?",
    "answer": "Дженерики – это параметризованные типы. С их помощью можно объявлять классы, интерфейсы и методы, в которых тип данных указан в виде параметра. Используя дженерики, можно создать единственный класс, который будет автоматически работать с разными типами данных. Эта информация доступна только на этапе компиляции и стирается в runtime, и в байт код попадет только информация о том, что в программе есть некий список List&ltObject&gt list вместо List&ltString&gt list, например. Появились в версии 1.5"
  },
  "2002": {
    "id": 2002,
    "question": "Для чего нужны дженерики?",
    "answer": "Для строгой типизации и проверки на этапе компиляции. Дженерики позволяют передавать тип объекта компилятору в форме <тип>. Таким образом, компилятор может выполнить все необходимые действия по проверке типов во время компиляции, обеспечивая безопасность по приведению типов во время выполнения."
  },
  "2003": {
    "id": 2003,
    "question": "Что такое сырые типы (raw type)?",
    "answer": "Сырые типы — это типы без указания типа в фигурных скобках ( List list = new ArrayList<>() ), они использовались до появления дженериков. Не указывая их, под капотом используется Object."
  },
  "2004": {
    "id": 2004,
    "question": "Что такое вайлдкарды?",
    "answer": "Маске (wildcard) можно задать ограничения: <p>-“? extends T” (для получения в методе)  - объект, который наследуется от Т, либо сам Т – ковариантность. Если контейнер объявлен ? extends T, то можно только читать значения. В список нельзя ничего добавить, кроме null.<p>-“? super T” (для отдачи в методе) - любой объект подтипа Т, включая Т – контравариантность. Нельзя прочитать элемент из контейнера с wildcard ? super, кроме объекта класса Object <p>При использовании ? мы сообщаем компилятору, чтобы он игнорировал информацию о типе, т.е. <?> - неограниченный символ подстановки. <?> означает то же что и <? extends Object>, т.е. принимает всё. Это можно обойти, создав обобщенный метод, объявленный с переменной типа T."
  },
  "2005": {
    "id": 2005,
    "question": "Расскажите про принцип PECS",
    "answer": "Producer Extends Consumer Super <p>wildcard подстановочный знак: <p>Если мы объявили wildcard с extends, то это producer. Он только «производит», предоставляет элемент из контейнера, а сам ничего не принимает. <p>Если же мы объявили wildcard с super — то это consumer. Он только принимает, а предоставить ничего не может. <p>Иначе говоря: <p>Если вы только получаете объекты из дженерик-коллекции - это producer и надо использовать extends. <p>Если вы только кладете объекты в коллекцию - это consumer и надо использовать super. <p>Если вы делаете оба эти действия, то не надо использовать ни super, ни extends."
  },
  "2006": {
    "id": 2006,
    "question": "Что такое «коллекция»?",
    "answer": "Коллекция – это объект, который содержит набор объектов одного типа. Каждый из этих объектов в коллекции называется элементом."
  },
  "2007": {
    "id": 2007,
    "question": "Расскажите про иерархию коллекций",
    "answer": "Iterable - перечисляемые. <p>Vector - синхронизирован, поэтому методы медленные, т.к. можно несколько потоков, с одним работает, другие блокирует. <p>Stack - тоже синхронизирован.",
    "images": "images/dbImage/2007.png"
  },
  "2008": {
    "id": 2008,
    "question": "Почему Map — это не Collection, в то время как List и Set являются Collection?",
    "answer": "Коллекция (List и Set) представляет собой совокупность некоторых элементов (обычно экземпляров одного класса).Map -это совокупность пар &#8222ключ&#8221-&#8222значение&#8221. У map нет итерабл, не понятно по чему проводить итерацию"
  },
  "2009": {
    "id": 2009,
    "question": "В чем разница между java.util.Collection и java.util.Collections?",
    "answer": "Класс java.util.Collections содержит исключительно статические методы для работы с коллекциями. В них входят методы, реализующие полиморфные алгоритмы (такие алгоритмы, использование которых возможно с разными видами структур данных), &#8222оболочки&#8221, возвращающие новую коллекцию с инкапсулированной указанной структурой данных и некоторые другие методы. <p>sort () - сортирует по порядку;  <p>binarySearch () - деление напополам для быстрого поиска;  <p>reverse () - сортировка по убыванию; <p>copy() - копирует; <p>java.util.Collection - это корневой интерфейс Java Collections Framework. Этот интерфейс в основном применяется там, где требуется высокий уровень абстракции, например, в классе java.util.Collections. Классы реализующие Collection, могут добавлять, убирать, искать элементы коллекций. <p>Collection — это интерфейс, который содержит статический метод, начиная с java8. Интерфейс также может содержать абстрактные методы и методы по умолчанию. Он используется для представления группы отдельных объектов как единого целого. <p>Collections - класс, содержит только статические методы. Он определяет несколько служебных методов, которые используются для работы с коллекцией."
  },
  "2010": {
    "id": 2010,
    "question": "Какая разница между итераторами с fail-fast и fail-safe поведением? (С примерами)",
    "answer": "Никаких модификаций не допускается. Изменений структуры коллекции, уменьшать, добавлять... <p>Итератор fail-safe проходимся по коллекции и не вылетает ошибка при попытке удалить элемент, не вызывает исключений при изменении структуры коллекции, потому что работает с её клоном. Пример fail-safe -Итератор коллекции CopyOnWriteArrayList и итератор представления keySet коллекции ConcurrentHashMap. <p>Итератор fail-fast проходя по коллекции вылетает ошибка, т.к. проходим по коллекции пытаемся удалить элемент, генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, но работает быстрее. Пример fail-fast - Vector и Hashtable. fail-fast поведение означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом. Использование fail-fast подхода позволяет избежать недетерминированного поведения программы в течение времени. В Java Collections API некоторые итераторы ведут себя как fail-fast и выбрасывают ConcurrentModificationException, если после его создания была произведена модификация коллекции, т.е. добавлен или удален элемент напрямую из коллекции, а не используя методы итератора. <p>Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count): <p>- при изменении коллекции счетчик модификаций также изменяется; <p>- при создании итератора ему передается текущее значение счетчика; <p>- при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение. <p>Разница, при удалении значений и при добавлении значений. Добавление в конец, удаление может быть где удобно. <p>Fail-safe – «умный» итератор. Обычно плата за отказоустойчивость – возможная неконсистентность данных («слабая консистентность»). Итератор класса ConcurrentHashMap работает с копией данных, он не выбросит исключение при изменении коллекции, но может не увидеть часть свежих изменений. Плата за отсутствие ошибок других fail-safe итераторов может отличаться, детали всегда можно найти в документации коллекций. <p>Fail-fast – «быстрый» итератор. Когда после его создания коллекция как-либо изменилась, он падает с ошибкой без лишних разбирательств. Так работает итератор класса ArrayList, при изменении он выбрасывает ConcurrentModificationException. Рекомендуется не основывать логику программы на fail-fast отказах, и использовать их только как признак ошибки реализации."
  },
  "2011": {
    "id": 2011,
    "question": "Чем различаются Enumeration и Iterator?",
    "answer": "Iterator имеет больше методов работы с коллекциями и был специально введен в java2, вместо Enumeration(interface). Рекомендуется юзать Iterator. <p>Оба интерфейса предназначены для обхода коллекции, но есть различия: <p>-с помощью Enumeration нельзя добавлять/удалять элементы; <p>-в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д); <p>-Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных коллекциях."
  },
  "2012": {
    "id": 2012,
    "question": "Как между собой связаны Iterable, Iterator и «for-each»?",
    "answer": "Интерфейс Iterable имеет метод - iterator(), с типом возвращаемого значения - интерфейс Iterator. Экземпляры классов, реализующих интерфейс Iterable, могут использоваться в цикле foreach. <p>Что произойдет при вызове Iterator.next() без предварительного вызова Iterator.hasNext()? Если итератор указывает на последний элемент коллекции, то возникнет исключение NoSuchElementException, иначе будет возвращен следующий элемент. <p>Сколько элементов будет пропущено, если Iterator.next() будет вызван после 10-ти вызовов Iterator.hasNext()? Нисколько - hasNext() осуществляет только проверку наличия следующего элемента."
  },
  "2013": {
    "id": 2013,
    "question": "Можно ли итерируясь по ArrayList удалить элемент? Какое вылетит исключение?",
    "answer": "Можно, но нужно использовать iterator.remove(). Иначе при прохождении по ArrayList в цикле for сразу после удаления элемента будет ConcurrentModificationException. Как избежать ConcurrentModificationException во время перебора коллекции? <p>- Попробовать подобрать другой итератор, работающий по принципу fail-safe. К примеру, для List можно использовать ListIterator. <p>- Использовать ConcurrentHashMap и CopyOnWriteArrayList. <p>- Преобразовать список в массив и перебирать массив. <p>- Блокировать изменения списка на время перебора с помощью блока synchronized. <p>Отрицательная сторона последних двух вариантов - ухудшение производительности. <p>remove() - удаляет элемент, который был возвращен последним вызовом next. <p>Класс ConcurrentModificationException. Это исключение может быть выдано методами, которые обнаружили параллельную модификацию объекта, когда такая модификация не допустима."
  },
  "2014": {
    "id": 2014,
    "question": "Как поведёт себя коллекция, если вызвать iterator.remove()?",
    "answer": "Этот метод удаляет текущий элемент. Важный момент заключается в том, что сначала этот элемент необходимо получить с помощью метода next(), если мы вызовем метод remove() до метода next(), то мы получим IllegalStateException. <p>Класс IllegalStateException. Сигналы, что метод был вызван в недопустимое или несоответствующее время. Другими словами среда Java или приложение Java не находятся в соответствующем состоянии для требуемой работы."
  },
  "2015": {
    "id": 2015,
    "question": "Чем Set отличается от List?",
    "answer": "List - это упорядоченная последовательность элементов, можно получить по индексу, тогда как Set - это отдельный список элементов, который не упорядочен <p>List допускает дублирование, а Set не допускает дублирование элементов. <p>List разрешает любое количество нулевых значений в своей коллекции, а Set разрешает только одно нулевое значение в своей коллекции. <p>List может быть вставлен как в прямом, так и в обратном направлении с помощью Listiterator, тогда как Set можно просматривать только в прямом направлении с помощью итератора <p>Set не добавляет новых методов, только вносит изменения унаследованные. В частности, метод add() добавляет элемент в коллекцию и возвращает true, если не было такого элемента."
  },
  "2016": {
    "id": 2016,
    "question": "Расскажите про интерфейс Set.",
    "answer": "Интерфейс Set расширяет интерфейс Collection. <p>Set не добавляет новых методов, только вносит изменения унаследованные. <p>Set - неупорядоченный набор неповторяющихся элементов <p>В частности, метод add() добавляет элемент в коллекцию и возвращает true, если не было такого элемента. <p>Разрешено наличие только одной ссылки типа null. <p>Для Enum есть специальный класс java.util.EnumSet. Зачем? Чем авторов не устраивал HashSet или TreeSet? <p>EnumSet - это реализация интерфейса Set для использования с перечислениями (Enum). В структуре данных хранятся объекты только одного типа Enum, указываемого при создании. Для хранения значений EnumSet использует массив битов (bit vector), - это позволяет получить высокую компактность и эффективность. Проход по EnumSet осуществляется согласно порядку объявления элементов перечисления. Все основные операции выполняются за O(1) и обычно (но негарантированно) быстрей аналогов из HashSet, а пакетные операции (bulk operations), такие как containsAll() и retainAll() выполняются даже гораздо быстрей. Помимо всего EnumSet предоставляет множество статических методов инициализации для упрощенного и удобного создания экземпляров."
  },
  "2017": {
    "id": 2017,
    "question": "Расскажите про реализации интерфейса Set",
    "answer": "В HashSet порядок добавления элементов будет непредсказуемым - используется хэширование для ускорения выборки. <p>В TreeSet объекты хранятся отсортированными по возрастанию из-за применения к/ч дерева. <p>LinkedHashSet хранит элементы в порядке добавления."
  },
  "2018": {
    "id": 2018,
    "question": "В чем отличия TreeSet и HashSet?",
    "answer": "HashSet быстрее, чем TreeSet. <p>В HashSet элементы в случайном порядке, в TreeSet в отсортированном. <p>HashSet обеспечивает постоянную производительность - О(1) - для большинства операций, таких как add () , remove () и contains () , по сравнению с временем log(n), предлагаемым TreeSet."
  },
  "2019": {
    "id": 2019,
    "question": "Чем LinkedHashSet отличается от HashSet?",
    "answer": "Основное различие в том, что LinkedHashSet сохраняет порядок вставки элементов, а HashSet - нет. В основе LinkedHashSet лежит LinkedHashMap вместо HashMap. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов. <p>LinkedHashSet отличается от HashSet только тем, что в его основе лежит LinkedHashMap вместо HashMap. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов (insertion-order). При добавлении элемента, который уже присутствует в LinkedHashSet (т.е. с одинаковым ключом), порядок обхода элементов не изменяется."
  },
  "2020": {
    "id": 2020,
    "question": "Что будет, если добавлять элементы в TreeSet по возрастанию?",
    "answer": "TreeSet все равно в каком порядке вы добавляете в него элементы, так как в основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать и хранить элементы по возрастанию. предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering». <p>Реализованный в Comparable метод сравнения называют «natural ordering» — естественной сортировкой. Это потому, что в методе compareTo() ты описываешь наиболее распространенный способ сравнения, который будет использоваться для объектов этого класса в твоей программе. Natural Ordering уже присутствует в Java."
  }


}